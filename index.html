<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Running Duck</title>
<style>
html,body{margin:0;padding:0;overflow:hidden;background:#87CEEB;}
canvas{display:block;margin:auto;}
</style>
</head>
<body>
<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

function resize(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
window.addEventListener("resize", resize);
resize();

/* ================= LOADERS ================= */

function loadImage(src){
  const img = new Image();
  img.src = src;
  img.loaded = false;
  img.onload = () => img.loaded = true;
  return img;
}

function loadAudio(src){
  const a = new Audio(src);
  a.preload = "auto";
  return a;
}

function playSound(s){
  try{
    s.currentTime = 0;
    s.play();
  }catch(e){}
}

function playRandom(arr){
  const s = arr[Math.floor(Math.random()*arr.length)];
  playSound(s);
}

/* ================= ASSETS ================= */

const IMG = {
  duck: loadImage("duck.png"),
  obstacle: loadImage("obstacle.png"),
  beer: loadImage("beer.png"),
  boss: loadImage("boss.png"),
  bgFar: loadImage("bg_far.png"),
  tree: loadImage("bg_mid.png")
};

const SFX = {
  jump:[loadAudio("jump1.mp3"), loadAudio("jump2.mp3")],
  quack:[loadAudio("quack1.mp3"), loadAudio("quack2.mp3")],
  hit: loadAudio("hit.mp3"),
  power: loadAudio("power.mp3"),
  boss: loadAudio("boss.mp3")
};

/* ================= CAMERA SHAKE ================= */

let shakeTime = 0;
let shakePower = 0;

function triggerShake(power, duration){
  shakePower = power;
  shakeTime = duration;
}

/* ================= FAR BACKGROUND ================= */

class Parallax{
  constructor(img, speed){
    this.img = img;
    this.speed = speed;
    this.x = 0;
  }
  update(dt){
    this.x -= this.speed * dt;
    if(this.x <= -canvas.width) this.x = 0;
  }
  draw(){
    if(!this.img.loaded) return;
    ctx.drawImage(this.img, this.x, 0, canvas.width, canvas.height*0.7);
    ctx.drawImage(this.img, this.x + canvas.width, 0, canvas.width, canvas.height*0.7);
  }
}

const bgFar = new Parallax(IMG.bgFar, 20);

/* ================= TREE LAYER ================= */

class TreeLayer {
  constructor(img, speed) {
    this.img = img;
    this.speed = speed;
    this.trees = [];
    this.spawnInitial();
  }

  spawnInitial() {
    const spacing = 500;
    for (let i = 0; i < 6; i++) {
      this.trees.push({
        x: i * spacing,
        scale: 0.6 + Math.random() * 0.4
      });
    }
  }

  update(dt) {
    for (let tree of this.trees) {
      tree.x -= this.speed * dt;
    }

    if (this.trees.length && this.trees[0].x < -300) {
      this.trees.shift();
    }

    const last = this.trees[this.trees.length - 1];
    if (last && last.x < canvas.width - 500) {
      this.trees.push({
        x: canvas.width + Math.random() * 200,
        scale: 0.6 + Math.random() * 0.4
      });
    }
  }

  draw() {
    if (!this.img.loaded) return;

    for (let tree of this.trees) {
      const w = this.img.width * tree.scale;
      const h = this.img.height * tree.scale;

      ctx.drawImage(
        this.img,
        tree.x,
        canvas.height - h - 80,
        w,
        h
      );
    }
  }
}

const trees = new TreeLayer(IMG.tree, 80);

/* ================= DUCK ================= */

class Duck{
  constructor(){
    this.w = 130;
    this.h = 130;
    this.x = 150;
    this.groundY = canvas.height - 160;
    this.y = this.groundY;
    this.vy = 0;
    this.gravity = 2200;
    this.jumpV = -900;
    this.grounded = true;
    this.rot = 0;
  }

  jump(){
    if(!this.grounded) return;
    this.vy = this.jumpV;
    this.grounded = false;
    playRandom(SFX.jump);
    playRandom(SFX.quack);
  }

  update(dt){
    this.vy += this.gravity * dt;
    this.y += this.vy * dt;

    if(this.y >= this.groundY){
      this.y = this.groundY;
      this.vy = 0;
      this.grounded = true;
    }

    if(!this.grounded) this.rot += 0.1;
    else this.rot *= 0.85;
  }

  draw(invincible){
    if(!IMG.duck.loaded) return;

    ctx.save();
    ctx.translate(this.x + this.w/2, this.y + this.h/2);
    ctx.rotate(this.rot);

    if(invincible){
      ctx.shadowBlur = 25;
      ctx.shadowColor = "yellow";
    }

    ctx.drawImage(IMG.duck, -this.w/2, -this.h/2, this.w, this.h);
    ctx.restore();
  }

  get hitbox(){
    return { x:this.x+40, y:this.y+40, w:this.w-80, h:this.h-60 };
  }
}

/* ================= OBSTACLE ================= */

class Obstacle{
  constructor(speed){
    this.w = 80;
    this.h = 100;
    this.x = canvas.width + 100;
    this.y = canvas.height - 140;
    this.speed = speed;
  }
  update(dt){ this.x -= this.speed * dt; }
  draw(){
    if(IMG.obstacle.loaded)
      ctx.drawImage(IMG.obstacle,this.x,this.y,this.w,this.h);
  }
  get hitbox(){ return this; }
}

/* ================= BEER ================= */

class Beer{
  constructor(){
    this.w = 70;
    this.h = 70;
    this.x = canvas.width + 200;
    this.y = canvas.height - 230;
    this.speed = 300;
  }
  update(dt){ this.x -= this.speed * dt; }
  draw(){
    if(IMG.beer.loaded)
      ctx.drawImage(IMG.beer,this.x,this.y,this.w,this.h);
  }
  get hitbox(){ return this; }
}

/* ================= BOSS ================= */

class Boss{
  constructor(){
    this.w=250;
    this.h=250;
    this.x=canvas.width+400;
    this.y=80;
    this.speed=200;
    this.active=false;
  }
  activate(){
    this.active=true;
    playSound(SFX.boss);
  }
  update(dt){
    if(!this.active) return;
    if(this.x > canvas.width-350)
      this.x -= this.speed * dt;
  }
  draw(){
    if(this.active && IMG.boss.loaded)
      ctx.drawImage(IMG.boss,this.x,this.y,this.w,this.h);
  }
}

/* ================= GAME ================= */

let duck=new Duck();
let obstacles=[];
let beer=null;
let boss=new Boss();
let score=0;
let invTimer=0;
let worldSpeed=500;
let spawnTimer=0;
let last=performance.now();
let state="MENU";

function reset(){
  duck=new Duck();
  obstacles=[];
  beer=null;
  boss=new Boss();
  score=0;
  invTimer=0;
}

function checkCollision(a,b){
  return(
    a.x<b.x+b.w &&
    a.x+a.w>b.x &&
    a.y<b.y+b.h &&
    a.y+a.h>b.y
  );
}

function update(dt){
  bgFar.update(dt);
  trees.update(dt);

  if(state!=="PLAYING") return;

  duck.update(dt);
  invTimer=Math.max(0,invTimer-dt);

  spawnTimer+=dt;
  if(spawnTimer>2){
    spawnTimer=0;
    obstacles.push(new Obstacle(worldSpeed));
  }

  obstacles.forEach(o=>o.update(dt));
  obstacles=obstacles.filter(o=>o.x>-100);

  if(Math.random()<0.003 && !beer)
    beer=new Beer();

  if(beer){
    beer.update(dt);
    if(checkCollision(duck.hitbox,beer.hitbox)){
      invTimer=4;
      playSound(SFX.power);
      triggerShake(25,0.4);
      beer=null;
    }
  }

  for(const o of obstacles){
    if(checkCollision(duck.hitbox,o.hitbox)){
      if(invTimer<=0){
        playSound(SFX.hit);
        triggerShake(30,0.5);
        state="GAMEOVER";
      }
    }
  }

  if(score>30 && !boss.active)
    boss.activate();

  boss.update(dt);

  score+=dt*3;
}

function draw(){
  ctx.save();

  if(shakeTime>0){
    const dx=(Math.random()-0.5)*shakePower;
    const dy=(Math.random()-0.5)*shakePower;
    ctx.translate(dx,dy);
    shakeTime-=1/60;
  }

  ctx.clearRect(-100,-100,canvas.width+200,canvas.height+200);

  bgFar.draw();
  trees.draw();

  ctx.fillStyle="#228B22";
  ctx.fillRect(0,canvas.height-80,canvas.width,80);

  duck.draw(invTimer>0);
  obstacles.forEach(o=>o.draw());
  if(beer) beer.draw();
  boss.draw();

  ctx.fillStyle="#000";
  ctx.font="20px Arial";
  ctx.fillText("Score: "+Math.floor(score),20,40);

  ctx.restore();
}

function loop(now){
  const dt=Math.min(0.033,(now-last)/1000);
  last=now;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

window.addEventListener("keydown",e=>{
  if(e.key===" "){
    if(state==="MENU") state="PLAYING";
    else if(state==="GAMEOVER"){ reset(); state="PLAYING"; }
    else duck.jump();
  }
});
canvas.addEventListener("mousedown",()=>{
  if(state==="MENU") state="PLAYING";
  else if(state==="GAMEOVER"){ reset(); state="PLAYING"; }
  else duck.jump();
});
</script>
</body>
</html>