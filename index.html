<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport"
content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Running Duck</title>

<style>
html,body{
  margin:0;
  padding:0;
  overflow:hidden;
  touch-action:none;
  background:#87CEEB;
}
canvas{
  display:block;
}
</style>
</head>
<body>
<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

let DPR = window.devicePixelRatio || 1;

function resize(){
  const w = window.innerWidth;
  const h = window.innerHeight;

  canvas.width = w * DPR;
  canvas.height = h * DPR;
  canvas.style.width = w + "px";
  canvas.style.height = h + "px";

  ctx.setTransform(DPR,0,0,DPR,0,0);
}
window.addEventListener("resize", resize);
resize();

/* ================= LOADERS ================= */

function loadImage(src){
  const img = new Image();
  img.src = src;
  img.loaded = false;
  img.onload = () => img.loaded = true;
  return img;
}

function loadAudio(src){
  const a = new Audio(src);
  a.preload = "auto";
  return a;
}

function playSound(s){
  try{
    s.currentTime = 0;
    s.play();
  }catch(e){}
}

function playRandom(arr){
  playSound(arr[Math.floor(Math.random()*arr.length)]);
}

/* ================= ASSETS ================= */

const IMG = {
  duck: loadImage("duck.png"),
  obstacle: loadImage("obstacle.png"),
  beer: loadImage("beer.png"),
  boss: loadImage("boss.png"),
  bgFar: loadImage("bg_far.png"),
  tree: loadImage("bg_mid.png")
};

const SFX = {
  jump:[loadAudio("jump1.mp3"), loadAudio("jump2.mp3")],
  quack:[loadAudio("quack1.mp3"), loadAudio("quack2.mp3")],
  hit: loadAudio("hit.mp3"),
  power: loadAudio("power.mp3"),
  boss: loadAudio("boss.mp3")
};

/* ================= MOBILE AUDIO UNLOCK ================= */

let audioUnlocked=false;
function unlockAudio(){
  if(audioUnlocked) return;
  Object.values(SFX).flat().forEach(s=>{
    if(s.play){
      s.play().then(()=>s.pause()).catch(()=>{});
    }
  });
  audioUnlocked=true;
}

/* ================= CAMERA SHAKE ================= */

let shakeTime=0;
let shakePower=0;
function triggerShake(power,duration){
  shakePower=power;
  shakeTime=duration;
}

/* ================= BACKGROUND ================= */

class Parallax{
  constructor(img,speed){
    this.img=img;
    this.speed=speed;
    this.x=0;
  }
  update(dt){
    this.x-=this.speed*dt;
    if(this.x<=-canvas.width) this.x=0;
  }
  draw(){
    if(!this.img.loaded) return;
    ctx.drawImage(this.img,this.x,0,canvas.width/DPR,canvas.height*0.7/DPR);
    ctx.drawImage(this.img,this.x+canvas.width/DPR,0,canvas.width/DPR,canvas.height*0.7/DPR);
  }
}

class TreeLayer{
  constructor(img,speed){
    this.img=img;
    this.speed=speed;
    this.trees=[];
    this.spawn();
  }
  spawn(){
    const spacing=500;
    for(let i=0;i<6;i++){
      this.trees.push({x:i*spacing,scale:0.6+Math.random()*0.4});
    }
  }
  update(dt){
    this.trees.forEach(t=>t.x-=this.speed*dt);
    if(this.trees.length && this.trees[0].x<-300) this.trees.shift();
    const last=this.trees[this.trees.length-1];
    if(last && last.x<canvas.width/DPR-500){
      this.trees.push({x:canvas.width/DPR+200,scale:0.6+Math.random()*0.4});
    }
  }
  draw(){
    if(!this.img.loaded) return;
    this.trees.forEach(t=>{
      const w=this.img.width*t.scale;
      const h=this.img.height*t.scale;
      ctx.drawImage(this.img,t.x,(canvas.height/DPR)-h-80,w,h);
    });
  }
}

const bgFar=new Parallax(IMG.bgFar,20);
const trees=new TreeLayer(IMG.tree,80);

/* ================= DUCK ================= */

class Duck{
  constructor(){
    this.w=Math.min(140,window.innerWidth*0.25);
    this.h=this.w;
    this.x=window.innerWidth*0.15;
    this.groundY=window.innerHeight-160;
    this.y=this.groundY;
    this.vy=0;
    this.gravity=2200;
    this.jumpV=-900;
    this.grounded=true;
    this.rot=0;
  }
  jump(){
    if(!this.grounded) return;
    this.vy=this.jumpV;
    this.grounded=false;
    playRandom(SFX.jump);
    playRandom(SFX.quack);
  }
  update(dt){
    this.vy+=this.gravity*dt;
    this.y+=this.vy*dt;
    if(this.y>=this.groundY){
      this.y=this.groundY;
      this.vy=0;
      this.grounded=true;
    }
    if(!this.grounded) this.rot+=0.1;
    else this.rot*=0.85;
  }
  draw(inv){
    if(!IMG.duck.loaded) return;
    ctx.save();
    ctx.translate(this.x+this.w/2,this.y+this.h/2);
    ctx.rotate(this.rot);
    if(inv){
      ctx.shadowBlur=25;
      ctx.shadowColor="yellow";
    }
    ctx.drawImage(IMG.duck,-this.w/2,-this.h/2,this.w,this.h);
    ctx.restore();
  }
  get hitbox(){
    return {x:this.x+40,y:this.y+40,w:this.w-80,h:this.h-60};
  }
}

/* ================= GAME ================= */

let duck=new Duck();
let obstacles=[];
let beer=null;
let score=0;
let invTimer=0;
let spawnTimer=0;
let worldSpeed=500;
let state="MENU";
let last=performance.now();

class Obstacle{
  constructor(speed){
    this.w=80;
    this.h=100;
    this.x=window.innerWidth+100;
    this.y=window.innerHeight-140;
    this.speed=speed;
  }
  update(dt){ this.x-=this.speed*dt; }
  draw(){ if(IMG.obstacle.loaded) ctx.drawImage(IMG.obstacle,this.x,this.y,this.w,this.h); }
  get hitbox(){ return this; }
}

class Beer{
  constructor(){
    this.w=70; this.h=70;
    this.x=window.innerWidth+200;
    this.y=window.innerHeight-250;
    this.speed=300;
  }
  update(dt){ this.x-=this.speed*dt; }
  draw(){ if(IMG.beer.loaded) ctx.drawImage(IMG.beer,this.x,this.y,this.w,this.h); }
  get hitbox(){ return this; }
}

function reset(){
  duck=new Duck();
  obstacles=[];
  beer=null;
  score=0;
  invTimer=0;
}

function checkCollision(a,b){
  return(
    a.x<b.x+b.w &&
    a.x+a.w>b.x &&
    a.y<b.y+b.h &&
    a.y+a.h>b.y
  );
}

function update(dt){
  bgFar.update(dt);
  trees.update(dt);

  if(state!=="PLAYING") return;

  duck.update(dt);
  invTimer=Math.max(0,invTimer-dt);

  spawnTimer+=dt;
  if(spawnTimer>2){
    spawnTimer=0;
    obstacles.push(new Obstacle(worldSpeed));
  }

  obstacles.forEach(o=>o.update(dt));
  obstacles=obstacles.filter(o=>o.x>-100);

  if(Math.random()<0.003 && !beer)
    beer=new Beer();

  if(beer){
    beer.update(dt);
    if(checkCollision(duck.hitbox,beer.hitbox)){
      invTimer=4;
      playSound(SFX.power);
      triggerShake(25,0.4);
      beer=null;
    }
  }

  for(const o of obstacles){
    if(checkCollision(duck.hitbox,o.hitbox)){
      if(invTimer<=0){
        playSound(SFX.hit);
        triggerShake(30,0.5);
        state="GAMEOVER";
      }
    }
  }

  score+=dt*3;
}

function draw(){
  ctx.save();

  if(shakeTime>0){
    ctx.translate((Math.random()-0.5)*shakePower,(Math.random()-0.5)*shakePower);
    shakeTime-=1/60;
  }

  ctx.clearRect(0,0,canvas.width,canvas.height);

  bgFar.draw();
  trees.draw();

  ctx.fillStyle="#228B22";
  ctx.fillRect(0,window.innerHeight-80,window.innerWidth,80);

  duck.draw(invTimer>0);
  obstacles.forEach(o=>o.draw());
  if(beer) beer.draw();

  ctx.fillStyle="#000";
  ctx.font="28px Arial";
  ctx.fillText("Score: "+Math.floor(score),20,40);

  ctx.restore();
}

function loop(now){
  const dt=Math.min(0.033,(now-last)/1000);
  last=now;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* ================= CONTROLS ================= */

function handleInput(){
  unlockAudio();
  if(state==="MENU") state="PLAYING";
  else if(state==="GAMEOVER"){ reset(); state="PLAYING"; }
  else duck.jump();
}

window.addEventListener("keydown",e=>{
  if(e.key===" ") handleInput();
});

canvas.addEventListener("touchstart",e=>{
  e.preventDefault();
  handleInput();
},{passive:false});

canvas.addEventListener("mousedown",handleInput);

</script>
</body>
</html>
